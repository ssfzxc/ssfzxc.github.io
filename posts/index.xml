<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ssfzxc&#39;s blog</title>
    <link>https://ssfzxc.github.io/posts/</link>
    <description>Recent content in Posts on ssfzxc&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>youremail@domain.com (Some Person)</managingEditor>
    <webMaster>youremail@domain.com (Some Person)</webMaster>
    <lastBuildDate>Thu, 08 Jul 2021 11:26:51 +0800</lastBuildDate><atom:link href="https://ssfzxc.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hello</title>
      <link>https://ssfzxc.github.io/posts/hello/</link>
      <pubDate>Thu, 08 Jul 2021 11:26:51 +0800</pubDate>
      <author>youremail@domain.com (Some Person)</author>
      <guid>https://ssfzxc.github.io/posts/hello/</guid>
      <description>Hello </description>
    </item>
    
    <item>
      <title></title>
      <link>https://ssfzxc.github.io/posts/0-hello/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>youremail@domain.com (Some Person)</author>
      <guid>https://ssfzxc.github.io/posts/0-hello/</guid>
      <description>你好 ##*** 0
也不知道要干嘛，有点浮躁，决定静下心来写点什么,就从最近怎么折腾的Coroutine开始吧。
工作 本人从事Java开发</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ssfzxc.github.io/posts/1-ifeelcoroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>youremail@domain.com (Some Person)</author>
      <guid>https://ssfzxc.github.io/posts/1-ifeelcoroutine/</guid>
      <description>简单说说，我觉得的协程(Coroutine)   coroutine async await
Coroutine单从IO方面, 浅谈个人的看法和想法, 并非专业角度
此为杂谈, 内容有点乱, 后期有空再优化(开发者都懂的有空再说^ ^)
 0. coroutine   bio 同步阻塞IO nio 同步非阻塞IO aio 异步IO   协程, 我最早开始知道这个概念是从Goroutine, 然后各大语言开始出现这个Feature(特性)(但是Java居然不跟进), 关键词async和await成为coroutine的标配. 如python的gevent(底层实现io的上下文切换), asyncio以及其配套lib(aiohttp, aiomysql), javascript的promise的概念拓展.
1 再说协程之前, 先谈下IO, IO作为Web开发者来说是一个熟悉的名词, io模型主要有blocking io(阻塞IO)和nonblocking io(非阻塞IO)以及asynchronous io(异步IO). 还有IO multiplexing(io多路复用)等等. Java的Tomcat7之前的版本使用的都是阻塞IO(bio), 都实现其高并发的方式是多线程, 单位时间内一个线程对应一个IO, 会导致连接数有限, 并发量上不去(生产环境通常会有负载均衡nginx/f5/..+多机部署解决问题), 而Tomcat7之后加入了非阻塞IO(nio), 其性能不会随线程增加而导致并发量的减少, 以及平均响应时间的恶化. 而Java的nio使用的模型是io多路复用.
通常使用bio进行读写io,阻塞的过程包括等待可读写状态和读写io数据流,而io多路复用将省去我们等待可读写状态的时间,通过注册消息交由系统内核去完成,如select/poll/epoll, 而epoll相对于前两者来说,优化了设置队列对象直接放于内核空间(前两者在用户空间创建队列而后拷贝至内核空间), 和返回就绪的队列而不是全部队列(全部队列需要遍历查询具体哪个为就绪).
表 相对来说, Python/Javascript的coroutine从实际应用来看,主要应用于io方面, 不但是aio还使代码逻辑没有断续感.
如下面的python代码,从http的请求到最后responsebody的读取,乃至于body转化为json对象都由aiohttp完成.
# 非完整代码 import aiohttp client = aiohttp.ClientSession() async def post(): async with client.</description>
    </item>
    
  </channel>
</rss>
